# 解题思路

## 1> 思路1：赋值新数组

根据题目描述，我们很容易想到通过创建一个新的数组，然后再将旧的数组中的元素，按照一定的规律，迁移到新的数组即可。那么题目中给出的数组长度是`2 * n`，那么要求最终的数据是`nums[0]，nums[n]，nums[1]，nums[n+1]，……`，所以我们只需要**遍历数组nums长度的一半**，即：n的长度就可以了。如下图中的红蓝两个指针，红色指针为`i`，那么蓝色指针为`i+n`，然后依次将获取到的数据保存到新的数组即可。具体操作如下图所示：

![1.png](https://pic.leetcode-cn.com/1661738922-kPccKZ-1.png)

思路1的逻辑比较简单，具体实现请参照：**实现1：赋值新数组**

## 2> 思路2：原数组内修改

上面思路1中我们创建了一个新的数组，所以它的空间复杂度是O(n)，那我们有没有一种方式，不去创建这个新的数组呢？使得空间复杂度为O(1)呢？其实是可以的。通过题目描述，我们可以知道数组中元素值的范围是：`1` <= nums[i] <= `10^3`。 那么最大值也就是1000了，将其转换为2进制为1111101000，只占了总共32位中的低10位。那么理论上，低10位如果都是1的话，值为1023，**我们要是想获得某32位中低10位的值，就可以通过按位与（&）1023来获得了**。那既然旧值只使用了低10位，**还有22位是空闲的**，所以，我们就`将第19~10位作为新值的存储位置`（下图黄色部分）。具体逻辑，如下图所示：

![1.png](https://pic.leetcode-cn.com/1661738946-kJLkzt-1.png)

我们举例，要将nums[3]的值赋值到nums[1]的位置上。那么，首先获得nums[3]的值，因为该值要作为新的值，后续要放到nums[1]的第19至第10位上，所以，我们`先将其向左移动10位`，那么，它就处于第19位至第10位了。然后，我们再将其与nums[1]的值进行**按位或(|)**操作。那么最终nums[1]位置上的结果就是一个**包含了新值和旧值的结果**了。当所有元素都迁移完毕后，我们最终需要的还是新值，那怎么获取到呢？其实方法很简单，只需要**将nums数组中每个元素都向右移动10位就可以了**。具体操作如下图所示：

![1.png](https://pic.leetcode-cn.com/1661738964-bfVbfZ-1.png)

细心的同学会发现，上面的逻辑好像有问题吧，如果我们要将num[1]的值赋值给别的位置呢？此时的num[1]可是包含了新值和旧值了，那么这样不就有问题了吗？是这样的。所以，此时我们就需要1023这个值（`低10位都是1`）来获得nums[1]中的旧值了，具体来说，可以采用**按位与（&）**的方式，就可以了。具体如下图所示：

![1.png](https://pic.leetcode-cn.com/1661738984-qswsKd-1.png)

思路大致就是这些了，具体的实现，请参照：**实现2：原数组内修改**

# 代码实现

## 1> 实现1：赋值新数组

* java

```java
class Solution {
    public int[] shuffle(int[] nums, int n) {
        int[] result = new int[2*n];
        int index = 0;
        for (int i = 0; i < n; i++) {
            result[index++] = nums[i];
            result[index++] = nums[i + n];
        }
        return result;
    }
}
```

![1.png](https://pic.leetcode-cn.com/1661741305-OpgATF-1.png)

## 2> 实现2：原数组内修改

* java

```java
class Solution {
    public int[] shuffle(int[] nums, int n) {
        int index = 0, mask = (1 << 10) - 1;
        for (int i = 0; i < n; i++) {
            nums[index++] = (nums[i] & mask) << 10 | (nums[index - 1] & mask);
            nums[index++] = (nums[i + n] & mask) << 10 | (nums[index - 1] & mask);
        }
        for (int i = 0; i < 2*n; i++)  nums[i] >>= 10;
        return nums;
    }
}
```

![1.png](https://pic.leetcode-cn.com/1661741317-eDXySZ-1.png)

今天的文章内容就这些了：

> 写作不易，笔者几个小时甚至数天完成的一篇文章，只愿换来您几秒钟的 **点赞** & **分享** 。

更多技术干货，欢迎大家关注公众号“**爪哇缪斯**” ~ \\(^o^)/ ~ 「干货分享，每天更新」
